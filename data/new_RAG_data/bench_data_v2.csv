Code,Prompt
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

design_top_module_name = ""gcd""

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
verilogFile = designDir/str(""1_synth.v"")
design.readVerilog(verilogFile.as_posix())
design.link(design_top_module_name)

# Configure clock constraints
# Create 20ns period clock on clk port
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")

# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"")
utilization = 0.5
aspect_ratio = 1.0
leftSpace = design.micronToDBU(10)
rightSpace = design.micronToDBU(10)
topSpace = design.micronToDBU(10)
bottomSpace = design.micronToDBU(10)
floorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND, 
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),
        extend = pdn.CORE)
  
    # Create vertical power straps on metal4 and metal7
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create power grid for each macro
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 and metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Verify and build power grid
pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

# Write final odb file
design.writeDb(""final.odb"")

","
The Nangate45 library is located in the `../Design/nangate45/lib` directory, and the LEF files can be found in `../Design/nangate45/lef`. Your design file is `../Design/1_synth.v` with the top module named `gcd`. Follow these steps to set up and process the design in OpenROAD:

1. **Load Technology and Libraries:**
   - Load the Nangate45 technology files.
   - Read all `.lib` files from the `lib` directory.
   - Read all `.tech.lef` and `.lef` files from the `lef` directory.

2. **Read and Link Design:**
   - Import the Verilog design from `1_synth.v`.
   - Link the design using the top module `gcd`.

3. **Set Up Clock Constraints:**
   - Create a clock on the `clk` port with a 20ns period.
   - Name this timing domain `core_clock`.

4. **Floorplanning:**
   - Set the aspect ratio to 1.0 and utilization to 30%.
   - Ensure there is a 10µm margin on all sides of the die area.
   - Initialize the floorplan and create the necessary tracks.

5. **IO Pin Placement:**
   - Place IO pins on the metal8 (horizontal) and metal9 (vertical) layers.
   - Assign the pins accordingly.

6. **Macro Placement:**
   - Place macro blocks with a 2µm halo around each macro.
   - Set the fence region to the core area.
   - Align macro pins that are on metal4 with the track grid.

7. **Global Placement:**
   - Perform global placement with 10 iterations to optimize cell placement.

8. **Detailed Placement:**
   - Execute detailed placement allowing a maximum displacement of 1µm in the X direction and 3µm in the Y direction.

9. **Power Delivery Network (PDN) Setup:**
   - For standard cells, create PDN PG rings using metal1, metal4, metal7, and metal8 with a width and spacing of 2µm. Additionally, use metal1 with a width of 0.07µm.
   - Create straps:
     - Metal4: 1.2µm width, 1.2µm spacing, 6µm pitch.
     - Metal7 and metal8: 1.4µm width, 1.4µm spacing, 10.8µm pitch each.
   - For macros, design power grids using metal5 and metal6 with 1.2µm width and spacing, and a 6µm pitch.
   - Ensure via connections between all adjacent metal layers with a via pitch of 2µm.

10. **Set Electrical Parameters:**
    - Set unit resistance to 0.03574 and unit capacitance to 0.07516.
    - Use the buffer cell `BUF_X2` for clock tree synthesis (CTS).

11. **Insert Filler Cells:**
    - Place filler cells to complete the design.

12. **Routing:**
    - Perform global routing from metal1 to metal7.
    - Execute detailed routing to finalize connections.

13. **Save Outputs:**
    - Save the DEF file as `final.def`.
    - Save the netlist as `final.v`.
    - Save the OpenDB file as `final.odb`.

14. **Power Analysis:**
    - Run static IR drop analysis on the VDD net.
    - Report the switching power, internal power, and leakage power of the design.

Ensure each step is executed correctly to achieve a successful design flow in OpenROAD.

"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

design_top_module_name = ""gcd""

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
verilogFile = designDir/str(""1_synth.v"")
design.readVerilog(verilogFile.as_posix())
design.link(design_top_module_name)

# Configure clock constraints
# Create 20ns period clock on clk port
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")

# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"")
utilization = 0.5
aspect_ratio = 1.0
leftSpace = design.micronToDBU(10)
rightSpace = design.micronToDBU(10)
topSpace = design.micronToDBU(10)
bottomSpace = design.micronToDBU(10)
floorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
# Set core ring's width and spacing config to 2 μm
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
# Set core ring's offset to 0 μm (no offset from core boundary)
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area using metal7 and metal8
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,  # Extend to the power rings
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,  # Extend to the power rings
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8 (for ring connections)
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

# Write final odb file
design.writeDb(""final.odb"")

","
Load Nangate45 technology from ../Design/nangate45/lib and ../Design/nangate45/lef. Import the gcd design from ../Design/1_synth.v into OpenROAD. Set a 20ns period clock on the clk port and name the timing domain ""core_clock"". Perform floorplanning with a 1.0 aspect ratio, 30% utilization, and 10µm margins on all sides. Execute IO placement on metal8 and metal9 layers. Place macros with a 2µm halo around each and set the fence region to the core area. Align macro pins on metal4 with the track grid. Run global placement for 10 iterations, followed by detailed placement limiting displacement to 1µm in X and 3µm in Y. Construct the PDN as follows:

- **Standard Cells:**
  - Create PG rings using metal1, metal4, metal7, and metal8 with 2µm width and spacing.
  - Add power straps on metal1 with a width of 0.07µm.
  - Add straps on metal4 with 1.2µm width and spacing, pitch 6µm.
  - Add straps on metal7 and metal8 with 1.4µm width and spacing, pitch 10.8µm.

- **Macros:**
  - Create PG rings using metal5 and metal6 with 1.5µm width and spacing.
  - Add PG straps with 1.2µm width and spacing, pitch 6µm.

Set all unspecified PDN parameters to 0µm. Assign unit resistance to 0.03574 and unit capacitance to 0.07516. Use BUF_X2 for CTS. Insert filler cells. Execute global routing from metal1 to metal7. Save the DEF file as final.def, the netlist as final.v, and the odb as final.odb.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

design_top_module_name = ""gcd""

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
verilogFile = designDir/str(""1_synth.v"")
design.readVerilog(verilogFile.as_posix())
design.link(design_top_module_name)

# Configure clock constraints
# Create 20ns period clock on clk port
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")

# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"")
utilization = 0.5
aspect_ratio = 1.0
leftSpace = design.micronToDBU(10)
rightSpace = design.micronToDBU(10)
topSpace = design.micronToDBU(10)
bottomSpace = design.micronToDBU(10)
floorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final DEF file
design.writeDef(""final.def"")

# Write final odb file
design.writeDb(""final.odb"")

","
I have the Nangate45 library files in ../Design/nangate45/lib and the LEF files in ../Design/nangate45/lef. My design file is ../Design/1_synth.v for the gcd module. I need to use OpenROAD to load the Nangate45 technology and read in the gcd design.

First, set up a clock on the clk port with a 20ns period and name the timing domain core_clock. Then, perform floorplanning with a 1.0 aspect ratio and 30% utilization, making sure there's a 10µm margin on all edges.

Next, run the IO pin placement and assign the pins to metal8 and metal9 layers. After that, place the macros with a 2µm halo around them and set the fence region as the core area. Ensure that the macro pins on metal4 align with the track grid.

Proceed to run global placement with 10 iterations, followed by detailed placement where the maximum movement is 1µm in the x direction and 3µm in the y direction.

For the power delivery network (PDN), do the following:

- For standard cells, use metal1, metal4, metal7, and metal8. Set metal1 straps to 0.07µm width.
- On metal4, create straps with 1.2µm width and spacing, and a 6µm pitch.
- On metal7 and metal8, use straps with 1.4µm width and spacing, and a 10.8µm pitch.
- For macros, design PG rings using metal5 and metal6 with 1.5µm width and spacing.
- For macro PG straps, use 1.2µm width and spacing with a 6µm pitch.
- Use 0µm for any unspecified parameters.

Set the unit resistance to 0.03574 and unit capacitance to 0.07516. Use BUF_X2 as the buffer cell for clock tree synthesis (CTS). Insert filler cells, then run global routing from metal1 to metal7. Finally, save the DEF file as final.def and the ODB file as final.odb.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

design_top_module_name = ""gcd""

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
verilogFile = designDir/str(""1_synth.v"")
design.readVerilog(verilogFile.as_posix())
design.link(design_top_module_name)

# Configure clock constraints
# Create 20ns period clock on clk port
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")

import odb
# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
    design.micronToDBU(60), design.micronToDBU(50))
# Set core area to 50um x 40um with 5um margins
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
    design.micronToDBU(55), design.micronToDBU(45))
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"") 
floorplan.initFloorplan(die_area, core_area, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

","
- Locate Nangate45 library files in ../Design/nangate45/lib and LEF files in ../Design/nangate45/lef.
- Use ../Design/1_synth.v for the gcd design.
- Load Nangate45 technology into OpenROAD.
- Import the gcd design.
- Define a clock on the clk port with a 20ns period named core_clock.
- Floorplan with a die area of 60µm × 50µm and a core area of 50µm × 40µm, maintaining a 5µm margin on all sides.
- Execute IO placement, assigning pins to metal8 and metal9 layers.
- Place macros with a 2µm halo and set the fence region to the core area.
- Align macro pins on metal4 with the track grid.
- Perform global placement with 10 iterations.
- Conduct detailed placement allowing maximum displacements of 1µm (x-axis) and 3µm (y-axis).
- Create a power grid:
  - For standard cells, establish a PDN using metal1, metal4, metal7, and metal8.
  - Set metal1 straps to 0.07µm width.
  - On metal4, use straps with 1.2µm width, 1.2µm spacing, and a 6µm pitch.
  - On metal7 and metal8, use straps with 1.4µm width, 1.4µm spacing, and a 10.8µm pitch.
  - For macros' PG straps, set both width and spacing to 1.2µm with a 6µm pitch.
  - Assign 0µm to any unspecified parameters.
- Set unit resistance to 0.03574 and unit capacitance to 0.07516.
- Use BUF_X2 as the buffer cell for Clock Tree Synthesis (CTS).
- Insert filler cells.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
defFile = designDir/str(""1_synth.def"")
design.readDef(defFile.as_posix())

# Configure clock constraints
# Create 20ns period clock on clk port
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")

# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"")
utilization = 0.5
aspect_ratio = 1.0
leftSpace = design.micronToDBU(10)
rightSpace = design.micronToDBU(10)
topSpace = design.micronToDBU(10)
bottomSpace = design.micronToDBU(10)
floorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND, 
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),
        extend = pdn.CORE)
  
    # Create vertical power straps on metal4 and metal7
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create power grid for each macro
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 and metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Verify and build power grid
pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

","
The Nangate45 library is in the folder ../Design/nangate45/lib, and the LEF files are in ../Design/nangate45/lef. My gcd design file is at ../Design/1_synth.def. First, load the Nangate45 technology and import the design into OpenROAD. Set up a clock with a 20ns period on the clk port and call the timing domain core_clock. Next, do the floorplanning with an aspect ratio of 1.0 and use 30% of the area, making sure there's a 10µm margin on all sides.

After floorplanning, place the IO pins on the metal8 and metal9 layers. Then, place the macros with a 2µm halo around them and set the fence region to be the core area. Make sure the macro pins on metal4 align with the track grid. Proceed with global placement using 10 iterations, followed by detailed placement where cells can move up to 1µm in the x direction and 3µm in the y direction.

For the power delivery network (PDN), create PG rings for standard cells using metal1, metal4, metal7, and metal8 with 2µm width and spacing. Also, use metal1 with a width of 0.07µm. Add straps using metal4 (1.2µm width and spacing, 6µm pitch) and metal7 and metal8 (1.4µm width and spacing, 10.8µm pitch). For macros, design power grids with metal5 and metal6, both having 1.2µm width and spacing with a 6µm pitch. Ensure vias connect all adjacent metal layers with a 2µm pitch.

Set the unit resistance to 0.03574 and capacitance to 0.07516. Use the BUF_X2 buffer cell for clock tree synthesis (CTS). Insert filler cells where needed. Perform global routing from metal1 to metal7. Save the DEF file as final.def and the netlist as final.v. After that, run detailed routing and perform a static IR drop analysis on the VDD net. Finally, generate a report showing the switching power, internal power, and leakage power of the design.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
defFile = designDir/str(""1_synth.def"")
design.readDef(defFile.as_posix())

# Configure clock constraints
# Create 20ns period clock on clk port
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")

# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"")
utilization = 0.5
aspect_ratio = 1.0
leftSpace = design.micronToDBU(10)
rightSpace = design.micronToDBU(10)
topSpace = design.micronToDBU(10)
bottomSpace = design.micronToDBU(10)
floorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

# Write final odb file
design.writeDb(""final.odb"")

","
Set the Nangate45 library path to ../Design/nangate45/lib and LEF files to ../Design/nangate45/lef. Load the gcd design from ../Design/1_synth.def into OpenROAD. Initialize the Nangate45 technology.

Create a clock on the clk port with a 20ns period and name the timing domain core_clock. Floorplan the design with an aspect ratio of 1.0, 30% utilization, and 10µm margins on all sides.

Place IO pins on metal8 (horizontal) and metal9 (vertical) layers. Position macros with a 2µm halo and set the fence region to the core area. Ensure macro pins on metal4 align with the track grid.

Perform global placement with 10 iterations. Execute detailed placement allowing up to 1µm displacement in the x-direction and 3µm in the y-direction.

Design the Power Delivery Network (PDN) as follows:
- For standard cells, use metal1, metal4, metal7, and metal8.
- Metal1 straps: width 0.07µm.
- Metal4 straps: width and spacing 1.2µm, pitch 6µm.
- Metal7 and metal8 straps: width and spacing 1.4µm, pitch 10.8µm.
- For macros, create PG rings using metal5 and metal6 with 1.5µm width and spacing.
- Macro PG straps: width and spacing 1.2µm, pitch 6µm.
- Set unspecified parameters to 0µm.

Set unit resistance to 0.03574 and capacitance to 0.07516. Use BUF_X2 for clock tree synthesis (CTS). Insert filler cells.

Run global routing from metal1 to metal7, followed by detailed routing. Perform static IR drop analysis on the VDD net. Generate reports for switching power, internal power, and leakage power. Save the final design database as final.odb.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
defFile = designDir/str(""1_synth.def"")
design.readDef(defFile.as_posix())

# Configure clock constraints
# Create 20ns period clock on clk port
design.evalTclString(""create_clock -period 20 [get_ports clk] -name core_clock"")
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")

# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"")
utilization = 0.5
aspect_ratio = 1.0
leftSpace = design.micronToDBU(10)
rightSpace = design.micronToDBU(10)
topSpace = design.micronToDBU(10)
bottomSpace = design.micronToDBU(10)
floorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

","
The Nangate45 library files are in the ../Design/nangate45/lib folder, and the LEF files are in ../Design/nangate45/lef. The gcd design file is located at ../Design/1_synth.def. Start by loading the Nangate45 technology and importing the design into OpenROAD.

Set up a clock on the clk port with a 20ns period and name this timing domain core_clock. Next, perform floorplanning with an aspect ratio of 1.0 and aim for 30% utilization. Make sure there’s a 10µm margin on all sides of the layout.

Place the IO pins on the metal8 and metal9 layers. Then, place the macros with a 2µm halo around each one and set the fence region to cover the core area. Since the macros have pins on metal4, align these pins with the track grid.

Proceed with global placement using 10 iterations. After that, do a detailed placement, allowing a maximum movement of 1µm in the x direction and 3µm in the y direction.

Create a power grid following these rules:
- For standard cells, use metal1, metal4, metal7, and metal8 to build the PDN.
- On metal1, use power straps that are 0.07µm wide.
- On metal4, create straps that are 1.2µm wide and spaced 1.2µm apart with a 6µm pitch.
- On metal7 and metal8, use straps that are 1.4µm wide and spaced 1.4µm apart with a 10.8µm pitch.
- For macro power straps, set both the width and spacing to 1.2µm and use a 6µm pitch.
- Use 0µm for any other parameters not specified.

Set the unit resistance to 0.03574 and the unit capacitance to 0.07516. Use BUF_X2 as the buffer cell for clock tree synthesis (CTS). Insert filler cells into the design. Finally, run global routing from metal1 to metal7 and save the netlist as final.v.
"
"import odb
# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
    design.micronToDBU(60), design.micronToDBU(50))
# Set core area to 50um x 40um with 5um margins
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
    design.micronToDBU(55), design.micronToDBU(45))
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"") 
floorplan.initFloorplan(die_area, core_area, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

# Write final odb file
design.writeDb(""final.odb"")

","
Set up floorplan with a die size of 60µm by 50µm and a core area of 50µm by 40µm, maintaining a 5µm margin on each side. Execute IO placement, assigning pins to metal8 for horizontal and metal9 for vertical connections. Place macros with a 2µm halo and constrain them within the core area as a fence. Ensure macro pins on metal4 align with the track grid.

Proceed with global placement using 10 iterations followed by detailed placement, restricting displacement to 1µm in the x-direction and 3µm in the y-direction. Design the power delivery network (PDN) as follows:

- For standard cells, create PDN using metal1, metal4, metal7, and metal8. Utilize metal1 for bottom power straps with a width of 0.07µm.
- Add metal4 straps with 1.2µm width and spacing, pitched at 6µm.
- Implement metal7 and metal8 straps with 1.4µm width and spacing, pitched at 10.8µm.
- For macros, design PG rings using metal5 and metal6 with 1.5µm width and spacing.
- Create PG straps for macros with 1.2µm width and spacing, pitched at 6µm.
- Set all unspecified parameters to 0µm.

Assign unit resistance of 0.03574 and unit capacitance of 0.07516. Use BUF_X2 for clock tree synthesis (CTS). Insert filler cells. Perform global routing from metal1 to metal7. Export the DEF file as final.def and the netlist as final.v. Conduct detailed routing and perform static IR drop analysis on the VDD net. Report switching, internal, and leakage power. Save the OpenDB database as final.odb.
"
"import odb
# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
die_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  
    design.micronToDBU(60), design.micronToDBU(50))
# Set core area to 50um x 40um with 5um margins
core_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  
    design.micronToDBU(55), design.micronToDBU(45))
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"") 
floorplan.initFloorplan(die_area, core_area, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

","
Set up a floorplan with a die size of 60µm by 50µm. Make the core area 50µm by 40µm and leave a 5µm margin on each side. Place the IO pins using metal8 for horizontal connections and metal9 for vertical ones. When placing macros, keep a 2µm space around them and use the core area as a fence. Make sure the macro pins on metal4 match the track grid. Perform global placement with 10 iterations, then do detailed placement allowing up to 1µm movement in the x direction and 3µm in the y direction.

For the power delivery network (PDN), use metal1, metal4, metal7, and metal8 for standard cells. Use metal1 for the bottom power straps with a width of 0.07µm. On metal4, create straps that are 1.2µm wide and spaced 1.2µm apart with a 6µm pitch. On metal7 and metal8, make straps 1.4µm wide, spaced 1.4µm apart, and pitched at 10.8µm. For macros, add PG rings using metal5 and metal6 with both width and spacing set to 1.5µm. Also, add PG straps for macros with a width and spacing of 1.2µm and a 6µm pitch. Use 0µm for any other parameters not mentioned.

Set the unit resistance to 0.03574 and the unit capacitance to 0.07516. Use the BUF_X2 buffer cell for clock tree synthesis (CTS). Add filler cells to the design. Perform global routing from metal1 to metal7, then do detailed routing. Finally, save the netlist as final.v.
"
"# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"")
utilization = 0.5
aspect_ratio = 1.0
leftSpace = design.micronToDBU(10)
rightSpace = design.micronToDBU(10)
topSpace = design.micronToDBU(10)
bottomSpace = design.micronToDBU(10)
floorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final odb file
design.writeDb(""final.odb"")

","
Perform floorplanning with a 1.0 aspect ratio and 30% utilization. Maintain a 10µm margin on all sides. Execute IO pin placement on metal8 (horizontal) and metal9 (vertical) layers. Place macros with a 2µm halo and set the fence region to the core area. Align macro pins on metal4 with the track grid. Conduct global placement for 10 iterations, followed by detailed placement limiting displacement to 1µm in X and 3µm in Y directions.

Build the power grid as follows:
- **Standard Cells**:
  - Use metal1, metal4, metal7, and metal8 layers.
  - metal1: Bottom power straps, 0.07µm width.
  - metal4: Straps with 1.2µm width and spacing, 6µm pitch.
  - metal7 & metal8: Straps with 1.4µm width and spacing, 10.8µm pitch.
- **Macros**:
  - PG straps with 1.2µm width, spacing, and 6µm pitch.

Set all unspecified parameters to 0µm. Assign unit resistance to 0.03574 and unit capacitance to 0.07516. Use BUF_X2 for clock tree synthesis (CTS). Insert filler cells. Execute global routing from metal1 to metal7. Save the DEF file as final.def, the netlist as final.v, and the odb as final.odb. Complete the flow with detailed routing.
"
"# Initialize floorplan with core and die area
floorplan = design.getFloorplan()
# Set die area to 60um x 50um
# Initialize floorplan with FreePDK45 site
site = floorplan.findSite(""FreePDK45_38x28_10R_NP_162NW_34O"")
utilization = 0.5
aspect_ratio = 1.0
leftSpace = design.micronToDBU(10)
rightSpace = design.micronToDBU(10)
topSpace = design.micronToDBU(10)
bottomSpace = design.micronToDBU(10)
floorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)
floorplan.makeTracks()

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

","
Please help me create an OpenROAD script with the following steps:

1. Start by setting up the floorplan. Use an aspect ratio of 1.0 and set the utilization to 30%. Make sure there’s a 10µm margin on all sides.

2. Place the IO pins on the metal8 layer for horizontal pins and metal9 layer for vertical pins.

3. When placing macros, add a 2µm halo around each macro. Use the core area as the fence region. Ensure that the macro pins on metal4 align with the track grid.

4. Perform global placement and run it for 10 iterations.

5. For detailed placement, set the maximum displacement to 1µm in the x direction and 3µm in the y direction.

6. Create a power grid with these specifications:
   - For standard cells, use metal1, metal4, metal7, and metal8 layers.
   - On metal1, use bottom power straps that are 0.07µm wide.
   - On metal4, create straps with 1.2µm width and spacing, and a 6µm pitch.
   - On metal7 and metal8, use straps that are 1.4µm wide and spaced 1.4µm apart, with a 10.8µm pitch.
   - For macro power straps, both width and spacing should be 1.2µm with a 6µm pitch.
   - Use 0µm for any parameters not specified.

7. Set the unit resistance to 0.03574 and the unit capacitance to 0.07516. Use BUF_X2 as the buffer cell for clock tree synthesis (CTS).

8. Insert filler cells into the design.

9. Run global routing using metal1 through metal7 layers.

10. Finally, save the netlist as final.v.

Make sure to follow all the specifications closely. Thank you!
"
"# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND, 
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),
        extend = pdn.CORE)
  
    # Create vertical power straps on metal4 and metal7
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create power grid for each macro
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 and metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Verify and build power grid
pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

# Write final odb file
design.writeDb(""final.odb"")

","
Place the I/O pins on the metal8 and metal9 layers. Assign each pin to the appropriate metal layer. Next, perform macro placement with a 2µm halo around each macro. Define the fence region using the core area of the design. Ensure that macros with pins on metal4 have their pins aligned with the track grid.

Proceed with global placement using 10 iterations. After that, execute detailed placement allowing a maximum displacement of 1µm in the x-direction and 3µm in the y-direction.

Set up the Power Delivery Network (PDN) as follows:
- For standard cells, create PG rings using metal1, metal4, metal7, and metal8 layers with a width and spacing of 2µm each. Additionally, use metal1 with a width of 0.07µm.
- Add straps using metal4 with a width and spacing of 1.2µm and a 6µm pitch, and using metal7 and metal8 with a width and spacing of 1.4µm and a 10.8µm pitch.
- For macros, design power grids using metal5 and metal6, each with a width and spacing of 1.2µm and a 6µm pitch.
- Ensure via connections between all adjacent metal layers with a via pitch of 2µm.

Set the unit resistance to 0.03574 and the unit capacitance to 0.07516. Use the BUF_X2 buffer cell for Clock Tree Synthesis (CTS). Insert filler cells into the design. Perform global routing from metal1 to metal7, followed by detailed routing.

Run a static IR drop analysis on the VDD net. Finally, report the switching power, internal power, and leakage power of the design. Save the output database file as final.odb.
"
"# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

# Write final odb file
design.writeDb(""final.odb"")

","
Start by placing the IO pins on the metal8 and metal9 layers. Then, place the macros with a 2µm halo around each one and set the core area as the fence region. Since the macros have pins on metal4, make sure those pins align with the track grid. Next, run global placement for 10 iterations. After that, perform detailed placement allowing up to 1µm movement in the x direction and 3µm in the y direction. Finally, save the odb file as final.odb.
"
"# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final DEF file
design.writeDef(""final.def"")

","
Please create a Python script for OpenROAD that performs the following tasks:

1. **Macro Placement:**
   - Place macro blocks with a 2µm halo around each macro.
   - Define the core area as the fence region.
   - Ensure that all macro pins on metal4 are aligned with the track grid.

2. **Placement Steps:**
   - Execute global placement with 10 iterations.
   - Perform detailed placement allowing a maximum displacement of 1µm in the x-direction and 3µm in the y-direction.

3. **Power Delivery Network (PDN) Setup:**
   - For standard cells:
     - Use metal1, metal4, metal7, and metal8 to establish the PDN.
     - Set metal1 power straps to a width of 0.07µm.
     - Configure metal4 straps with a width and spacing of 1.2µm and a pitch of 6µm.
     - Configure metal7 and metal8 straps with a width and spacing of 1.4µm and a pitch of 10.8µm.
   - For macro PG straps:
     - Set both width and spacing to 1.2µm with a pitch of 6µm.
   - Leave all unspecified parameters at 0µm.

4. **Electrical Parameters and CTS:**
   - Set the unit resistance to 0.03574 and unit capacitance to 0.07516.
   - Use the BUF_X2 buffer cell for Clock Tree Synthesis (CTS).

5. **Additional Steps:**
   - Insert filler cells into the design.
   - Run global routing between metal1 and metal7.
   - Execute detailed routing.
   - Save the final design as `final.def`.

Make sure the script follows these instructions accurately and handles all configurations as specified.
"
"# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
# Set core ring's width and spacing config to 2 μm
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
# Set core ring's offset to 0 μm (no offset from core boundary)
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area using metal7 and metal8
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,  # Extend to the power rings
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,  # Extend to the power rings
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8 (for ring connections)
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final DEF file
design.writeDef(""final.def"")

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

# Write final odb file
design.writeDb(""final.odb"")

","
Please perform the following steps in OpenROAD:

1. Execute global placement with 10 iterations.
2. Run detailed placement, allowing up to 1µm movement in the x direction and 3µm in the y direction.
3. Build a Power Delivery Network (PDN) with these settings:
   - For standard cells:
     - Create PG rings using metal1, metal4, metal7, and metal8 layers. Set both the width and spacing of these rings to 2µm.
     - Use metal1 for power straps with a width of 0.07µm.
     - Add straps on metal4 with a width and spacing of 1.2µm and a pitch of 6µm.
     - Add straps on metal7 and metal8 with a width and spacing of 1.4µm and a pitch of 10.8µm.
   - For macro blocks:
     - Create PG rings using metal5 and metal6 layers, with both width and spacing set to 1.5µm.
     - Add PG straps with a width and spacing of 1.2µm and a pitch of 6µm.
   - Set any other unspecified parameters to 0µm.
4. Set the unit resistance to 0.03574 and the unit capacitance to 0.07516.
5. Use BUF_X2 as the buffer cell for Clock Tree Synthesis (CTS).
6. Insert filler cells into the design.
7. Perform global routing from metal1 to metal7.
8. Execute detailed routing.
9. Save the design as ""final.def"".
10. Conduct a static IR drop analysis on the VDD net.
11. Report the design's switching power, internal power, and leakage power.
12. Save the database file as ""final.odb"".
"
"# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND, 
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),
        extend = pdn.CORE)
  
    # Create vertical power straps on metal4 and metal7
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create power grid for each macro
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 and metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Verify and build power grid
pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final DEF file
design.writeDef(""final.def"")

","
Let's tackle a design flow using OpenROAD! Start by performing global placement with a focus on 10 iterations. After that's done, handle the detailed placement with a displacement limit set to 1µm in the x direction and 3µm in the y direction.

Next, build the power delivery network. For standard cells, use a setup with PG rings utilizing metal layers: metal1, metal4, metal7, and metal8. Ensure these rings have a width and spacing of 2µm. Additionally, configure metal1 with a width of 0.07µm. Create power straps on metal4 with a width and spacing of 1.2µm, and pitches of 6µm; also for metal7 and metal8 with widths and spacings of 1.4µm and pitches of 10.8µm. For macros, design grids using metal5 and metal6, each with a width and spacing of 1.2µm and 6µm pitch. Ensure via connections between all adjacent layers with a via pitch of 2µm.

Set unit resistance to 0.03574 and capacitance to 0.07516 for doing CTS, and use BUF_X2 for buffering. Insert filler cells to fill any empty spots. Wrap it up by executing global routing from metal1 to metal7 and save everything into a DEF file named final.def.
"
"# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND, 
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),
        extend = pdn.CORE)
  
    # Create vertical power straps on metal4 and metal7
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create power grid for each macro
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 and metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Verify and build power grid
pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final DEF file
design.writeDef(""final.def"")

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

","
Let's go through the steps to get our design ready using OpenROAD. First, we'll do a detailed placement. We want to set the max movement to 1 micron in the x direction and 3 microns in the y direction.

Next, we're going to make a PDN for our standard cells. Use metal layers 1, 4, 7, and 8 to create PG rings with a width and space of 2 microns. Also, let's make sure that metal1 is 0.07 microns wide.

For straps, metal4 should be 1.2 microns wide and spaced, with a 6-micron pitch. Use metal7 and metal8 with 1.4 microns width and spacing, and a pitch of 10.8 microns.

Now, for the macros, we need power grids. Use metal5 and metal6, each with a width and spacing of 1.2 microns and a 6-micron pitch.

We need to add vias between all nearby metal layers and keep their pitch at 2 microns.

We'll set our unit resistance to 0.03574 and unit capacitance to 0.07516. Also, the buffer cell for CTS is BUF_X2. We should insert filler cells, too.

Run global routing from metal1 to metal7. Let's save our work as final.def, and then do detailed routing. 

Finally, run a static IR drop analysis on the VDD net and report the design's switching power, internal power, and leakage power.
"
"# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

","
Run detailed placement allowing cells to be moved up to 1µm horizontally and 3µm vertically. For the power delivery network, follow these guidelines:
- Standard cells should use metal layers: metal1, metal4, metal7, and metal8.
  - Metal1 is reserved for bottom power straps with a width of 0.07µm.
  - Metal4 straps should have a width and spacing of 1.2µm, with a pitch of 6µm.
  - Metal7 and metal8 should have straps with 1.4µm width and spacing, and a pitch of 10.8µm.
- For macros, PG rings are required using metal5 and metal6. Both should have a width and spacing of 1.5µm.
- Also, set the width and spacing for macros' PG straps to 1.2µm with a 6µm pitch.

Configure unit resistance to be 0.03574 and unit capacitance at 0.07516. Use BUF_X2 as the buffer cell for the clock tree synthesis.

Apply 0µm wherever parameters are not specified.
"
"import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

# Write final odb file
design.writeDb(""final.odb"")

","
Hey, I need some help designing a power delivery network (PDN) using OpenROAD. Here’s what I’ve got:

First, for the standard cells, I want to lay down a PDN using metal layers 1, 4, 7, and 8. I'll start on metal1 with power straps that are 0.07µm wide for grounding. Then, I'd like to use metal4 for straps with widths and spacing of 1.2µm and pitch them at 6µm intervals. For metal7 and metal8, let's make the straps 1.4µm wide and spaced, with a pitch of 10.8µm.

For the macros, could you also design some power/ground rings? Let's use metal5 and metal6 this time, with each ring having both width and spacing set to 1.5µm. Also, for the straps connected to the macros, let's stick with the width and spacing set at 1.2µm, with a pitch of 6µm.

Also, please ensure that any values not mentioned, you set them to 0µm.

The unit resistance and capacitance should be set to 0.03574 and 0.07516 respectively. For the clock tree synthesis, let’s use BUF_X2 as our buffer cell. Remember to include filler cells, and then do global routing from metal1 to metal7, followed by detailed routing.

Finally, could you save the finished netlist as ""final.v"" and the overall design as ""final.odb""?

Thanks a lot for your help!
"
"import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

# Write final odb file
design.writeDb(""final.odb"")

","
Add filler cells to the design. Execute global routing from metal1 to metal7. Perform detailed routing. Save the DEF file as 'final.def'. Generate the netlist file named 'final.v'. Conduct a static IR drop analysis on the VDD net. Provide a report on switching, internal, and leakage power. Save the design database as 'final.odb'.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""2_floorplan.odb"")
design.readDb(odbFile.as_posix())

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND, 
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),
        extend = pdn.CORE)
  
    # Create vertical power straps on metal4 and metal7
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create power grid for each macro
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 and metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Verify and build power grid
pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

# Write final odb file
design.writeDb(""final.odb"")

","
Use the Nangate45 tech library from `../Design/nangate45/lib` and LEF in `../Design/nangate45/lef`. Design file is located at `../Design/2_floorplan.odb`. Bring the Nangate45 tech into OpenROAD; import this design.

IO pins need placement. Assign them to layers, metal8 and metal9. For macros, place them with a 2µm halo. Set your fence as the core zone. Macros' pins align on metal4’s track grid.

Carry out global placement, limiting to 10 iterations. Undertake detailed placement. Limit displacement: 1µm x, 3µm y.

Configure PDN. Use metal1, metal4, metal7, and metal8 for rings, 2µm width and spacing. Metal1 should be 0.07µm wide. Straps: metal4 (width/spacing 1.2µm, pitch 6µm), metal7, metal8 (width/spacing 1.4µm, pitch 10.8µm). For macros, craft grids with metal5, metal6 (width/spacing 1.2µm, pitch 6µm). Ensure via connections; pitch at 2µm.

Set unit resistance 0.03574, capacitance 0.07516. Utilize BUF_X2 for CTS. Insert filler cells. From metal1 to metal7, perform global routing, then detailed routing. Save as `final.v`.

Execute IR drop analysis on VDD net. Report power consumption: switching, internal, leakage. Finally, store the design as `final.odb`.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""2_floorplan.odb"")
design.readDb(odbFile.as_posix())

# Configure and run I/O pin placement
params = design.getIOPlacer().getParameters()
params.setRandSeed(42)
params.setMinDistanceInTracks(False)
params.setMinDistance(design.micronToDBU(0))
params.setCornerAvoidance(design.micronToDBU(0))
# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers
design.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(""metal8""))
design.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(""metal9""))
IOPlacer_random_mode = True
design.getIOPlacer().runAnnealing(IOPlacer_random_mode)

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final odb file
design.writeDb(""final.odb"")

","
Navigate to the directory containing the Nangate45 library's liberty and LEF files located at ../Design/nangate45/lib and ../Design/nangate45/lef respectively. Open the GCD design found at ../Design/2_floorplan.odb in OpenROAD.

Proceed to place the IO pins and assign them to metal8 and metal9 layers. When placing macros, ensure a 2µm halo is maintained around them. Align the macro pins on metal4 with the track grid. Use the core area as the fence region.

For global placement, carry out 10 iterations. While doing detailed placement, make sure the maximum displacement does not exceed 1µm in the x direction and 3µm in the y direction.

Moving on to the power delivery network: build a PDN using metal layers 1, 4, 7, and 8 for the standard cells. Set metal1 as the bottom strap with a width of 0.07µm. Design straps on metal4 with a 1.2µm width and spacing, having a 6µm pitch. On metal7 and metal8, aim for a 1.4µm width and spacing alongside a 10.8µm pitch. 

For macro PG rings, use metal5 and metal6, assigning a width and spacing of 1.5µm. PG straps for macros should have a width and spacing of 1.2µm with a 6µm pitch. Omit any unspecified parameters by using 0µm.

Set the unit resistance to 0.03574 and unit capacitance to 0.07516. Utilize BUF_X2 for clock tree synthesis. Add filler cells, execute global routing from metal1 to metal7, and finally save your work in final.odb.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""3_io.odb"")
design.readDb(odbFile.as_posix())

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
# Set core ring's width and spacing config to 2 μm
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
# Set core ring's offset to 0 μm (no offset from core boundary)
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area using metal7 and metal8
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,  # Extend to the power rings
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,  # Extend to the power rings
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8 (for ring connections)
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

","
Set Nangate45 lib path: ../Design/nangate45/lib. LEF path: ../Design/nangate45/lef.
Load tech and cell LEF files. Import GCD design from ../Design/3_io.odb into OpenROAD.
Macro placement: 2µm halo. Fence region: core area. Align metal4 pins to track grid.
Run global placement: 10 iterations. Detailed placement: max displacement 1µm (x), 3µm (y).
PDN: Standard cells - PG rings on metal1, metal4, metal7, metal8. Width & spacing: 2µm.
Use metal1 for power straps, 0.07µm width. Straps: metal4 (1.2µm width/spacing, 6µm pitch), metal7/8 (1.4µm width/spacing, 10.8µm pitch). Macros - PG rings on metal5, metal6. Width & spacing: 1.5µm. Macros PG straps: Width/spacing 1.2µm, pitch 6µm. Use 0µm for unmentioned parameters.
Set unit resistance: 0.03574, unit capacitance: 0.07516. Buffer cell for CTS: BUF_X2.
Insert filler cells. Global routing: metal1 to metal7. Save DEF: final.def. Save netlist: final.v. Run detailed routing.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""3_io.odb"")
design.readDb(odbFile.as_posix())

# Place macro blocks if present
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
if len(macros) > 0:
    mpl = design.getMacroPlacer()
    block = design.getBlock()
    core = block.getCoreArea()
    mpl.place(
        num_threads = 64, 
        max_num_macro = len(macros)//8,
        min_num_macro = 0,
        max_num_inst = 0,
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,
        halo_width = 2.0,
        halo_height = 2.0,
        fence_lx = block.dbuToMicrons(core.xMin()),
        fence_ly = block.dbuToMicrons(core.yMin()),
        fence_ux = block.dbuToMicrons(core.xMax()),
        fence_uy = block.dbuToMicrons(core.yMax()),
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0,
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,
        target_util = 0.25,
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4,
        bus_planning_flag = False,
        report_directory = """"
    )

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb

# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

","
Put the Nangate45 library files in ../Design/nangate45/lib and the LEF files in ../Design/nangate45/lef. Load the design from ""../Design/3_io.odb"" into OpenROAD and set up using the Nangate45 technology. When placing macros, make a halo of 2µm width around them. Align the metal4 macro pins with the track grid and define the core area as the fence region. Do global placement with 10 iterations. For detailed placement, allow max displacement of 1µm in x and 3µm in y. 

Next, set up the power grid. Use metal1, metal4, metal7, and metal8 for standard cells. Metal1 should be used for bottom power straps with a width of 0.07µm. Metal4 should have straps with a width and spacing of 1.2µm and a pitch of 6µm. For metal7 and metal8, keep straps at 1.4µm width and spacing with a pitch of 10.8µm. For macros, have strap width and spacing of 1.2µm and a pitch of 6µm. Assume 0µm for any unspecified parameters.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""4_mpl.odb"")
design.readDb(odbFile.as_posix())

# Configure and run global placement
gpl = design.getReplace()
gpl.setTimingDrivenMode(False)
gpl.setRoutabilityDrivenMode(True)
gpl.setUniformTargetDensityMode(True)
# Limit initial placement iterations and set density penalty
gpl.setInitialPlaceMaxIter(10)
gpl.setInitDensityPenalityFactor(0.05)
gpl.doInitialPlace(threads = 4)
gpl.doNesterovPlace(threads = 4)
gpl.reset()

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
# Set core ring's width and spacing config to 2 μm
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
# Set core ring's offset to 0 μm (no offset from core boundary)
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area using metal7 and metal8
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,  # Extend to the power rings
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,  # Extend to the power rings
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8 (for ring connections)
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final DEF file
design.writeDef(""final.def"")

","
Use Nangate45 libs in ../Design/nangate45/lib and LEFs in ../Design/nangate45/lef. GCD design at ../Design/4_mpl.odb. Load Nangate45 tech and read design into OpenROAD. Do global placement with 10 iterations. Perform detailed placement, max disp 1µm x and 3µm y. Set up PDN:
- Standard cells: PG rings with metals 1, 4, 7, 8. Width, spacing 2µm. Metal 1 power straps, width 0.07µm. Straps on metal 4, width 1.2µm, spacing 1.2µm, pitch 6µm. On metal 7, 8, width 1.4µm, spacing 1.4µm, pitch 10.8µm.
- Macros: PG rings on metal 5, 6. Width, spacing 1.5µm. PG straps, width, spacing 1.2µm, pitch 6µm.
All others 0µm.
Set unit resistance to 0.03574, capacitance to 0.07516. Use BUF_X2 for CTS. Insert filler cells. Run global routing, metals 1 to 7. Run detailed routing. Save DEF as final.def.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""5_gpl.odb"")
design.readDb(odbFile.as_posix())

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None
secondary = list()
# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND, 
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),
        extend = pdn.CORE)
  
    # Create vertical power straps on metal4 and metal7
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,
        nets = [])
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,
        nets = [])
  
    # Create via connections between power grid layers
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
for i in range(len(macros)):
    # Create power grid for each macro
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power straps on metal5 and metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.CORE,
            nets = [])
    
        # Create via connections between macro power grid layers
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Verify and build power grid
pdngen.checkSetup()
pdngen.buildGrids(False)
pdngen.writeToDb(True, )
pdngen.resetShapes()

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

","
1. The Nangate45 library and technology files are located in `../Design/nangate45/lib` and `../Design/nangate45/lef`. Start by loading these into OpenROAD alongside the `../Design/5_gpl.odb` design file.

2. Next, for the detailed placement, ensure your settings allow for a maximum move of 1µm in the x direction and 3µm in the y direction.

3. Construct the PDN with PG rings using metal1, metal4, metal7, and metal8. Set both width and spacing for these to 2µm. Also, use metal1 with a width of 0.07µm. Add straps on:
   - Metal4 with a width and spacing of 1.2µm, and a 6µm pitch.
   - Metal7 and metal8 each using a 1.4µm width and spacing, with a 10.8µm pitch.

4. Design macros should use power grids on metal5 and metal6, each having a 1.2µm width and spacing, and a 6µm pitch. Don’t forget via connections between adjacent metal layers, with a via pitch of 2µm.

5. Set your unit resistance to 0.03574 and capacitance to 0.07516. Use `BUF_X2` for Buffering during CTS. 

6. Remember to insert filler cells post-placement.

7. Proceed with global routing from metal1 to metal7, followed by detailed routing steps.

8. Save your design as `final.def` and your netlist as `final.v`.

9. Finally, conduct a static IR drop analysis on your VDD net. Make sure to report the switching power, internal power, and leakage power of your design.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""5_gpl.odb"")
design.readDb(odbFile.as_posix())

# Run initial detailed placement
site = design.getBlock().getRows()[0].getSite()
# Allow 1um x-displacement and 3um y-displacement
max_disp_x = int(design.micronToDBU(1))
max_disp_y = int(design.micronToDBU(3))
# Remove filler cells to be able to move the cells
design.getOpendp().removeFillers()
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
# Set core ring's width and spacing config to 2 μm
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
# Set core ring's offset to 0 μm (no offset from core boundary)
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area using metal7 and metal8
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,  # Extend to the power rings
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,  # Extend to the power rings
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8 (for ring connections)
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

","
Library: ../Design/nangate45/lib. LEF: ../Design/nangate45/lef. GCD: ../Design/5_gpl.odb. Load Nangate45 tech. Read design to OpenROAD. 

Placement: Detailed. Max displacement: 1µm x, 3µm y. 

PDN: 
- Standard cells: PG rings on metal1, metal4, metal7, metal8. Width and spacing: 2 µm. Power straps: metal1, width 0.07 µm.
- Straps: metal4, width and spacing 1.2 µm, pitch 6 µm; metal7 & metal8, width and spacing 1.4 µm, pitch 10.8 µm.
- Macros: PG rings on metal5, metal6. Width and spacing: 1.5 µm. Straps: width and spacing 1.2 µm, pitch 6 µm.

Units: Resistance 0.03574, Capacitance 0.07516. Buffer cell for CTS: BUF_X2. 

Steps: Insert fillers. Route: Global, layers metal1 to metal7. Save netlist: final.v.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""6_dpl.odb"")
design.readDb(odbFile.as_posix())

import pdn, odb
# Configure power delivery network
# Set up global power/ground connections
for net in design.getBlock().getNets():
    if net.getSigType() == ""POWER"" or net.getSigType() == ""GROUND"":
        net.setSpecial()  # Mark power/ground nets as special nets

# Find existing power and ground nets or create if needed
VDD_net = design.getBlock().findNet(""VDD"")
VSS_net = design.getBlock().findNet(""VSS"")
switched_power = None  # No switched power domain in this design
secondary = list()  # No secondary power nets

# Create VDD/VSS nets if they don't exist
if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), ""VDD"")
    VDD_net.setSpecial()
    VDD_net.setSigType(""POWER"")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), ""VSS"")
    VSS_net.setSpecial()
    VSS_net.setSigType(""GROUND"")

# Connect power pins to global nets
# Map standard VDD pins to power net for all instances
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"", 
    pinPattern = ""^VDD$"",
    net = VDD_net, 
    do_connect = True)
# Map peripheral domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDPE$"",
    net = VDD_net,
    do_connect = True)
# Map core domain VDD pins to power net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VDDCE$"",
    net = VDD_net,
    do_connect = True)
# Map standard VSS pins to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSS$"",
    net = VSS_net, 
    do_connect = True)
# Map VSS pins with 'E' suffix to ground net
design.getBlock().addGlobalConnect(region = None,
    instPattern = "".*"",
    pinPattern = ""^VSSE$"",
    net = VSS_net,
    do_connect = True)
# Apply the global connections
design.getBlock().globalConnect()

# Configure power domains
pdngen = design.getPdnGen()
# Set core power domain with primary power/ground nets
pdngen.setCoreDomain(power = VDD_net,
    switched_power = switched_power, 
    ground = VSS_net,
    secondary = secondary)

# Configure power ring dimensions
# Set core ring's width and spacing config to 2 μm
core_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]
core_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]
# Set core ring's offset to 0 μm (no offset from core boundary)
core_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
core_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
# Set via cut pitch to 0 μm
pdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]

# Get routing layers for power ring connections to pads
ring_connect_to_pad_layers = list()
for layer in design.getTech().getDB().getTech().getLayers():
    if layer.getType() == ""ROUTING"":
        ring_connect_to_pad_layers.append(layer)

# Create power grid for standard cells
domains = [pdngen.findDomain(""Core"")]
# Set halo around macros for power grid routing
halo = [design.micronToDBU(0) for i in range(4)]
for domain in domains:
    # Create the main core grid structure
    pdngen.makeCoreGrid(domain = domain,
    name = ""top"",
    starts_with = pdn.GROUND,  # Start with ground net
    pin_layers = [],
    generate_obstructions = [],
    powercell = None,
    powercontrol = None,
    powercontrolnetwork = ""STAR"")

# Get metal layers for power grid implementation
m1 = design.getTech().getDB().getTech().findLayer(""metal1"")
m4 = design.getTech().getDB().getTech().findLayer(""metal4"")
m7 = design.getTech().getDB().getTech().findLayer(""metal7"")
m8 = design.getTech().getDB().getTech().findLayer(""metal8"")

grid = pdngen.findGrid(""top"")
for g in grid:
    # Create power rings around core area using metal7 and metal8
    pdngen.makeRing(grid = g,
        layer0 = m7,
        width0 = core_ring_width[0],
        spacing0 = core_ring_spacing[0],
        layer1 = m8,
        width1 = core_ring_width[0],
        spacing1 = core_ring_spacing[0],
        starts_with = pdn.GRID,
        offset = core_ring_core_offset,
        pad_offset = core_ring_pad_offset,
        extend = False,
        pad_pin_layers = ring_connect_to_pad_layers,
        nets = [],
        allow_out_of_die = True)
  
    # Create horizontal power straps on metal1 for standard cell power rail connections
    pdngen.makeFollowpin(grid = g,
        layer = m1, 
        width = design.micronToDBU(0.07),  # 0.07μm straps for standard cell rails
        extend = pdn.CORE)
  
    # Create power straps on metal4 with 1.2μm width and 6μm pitch
    pdngen.makeStrap(grid = g,
        layer = m4,
        width = design.micronToDBU(1.2), 
        spacing = design.micronToDBU(1.2),
        pitch = design.micronToDBU(6),
        offset = design.micronToDBU(0), 
        number_of_straps = 0,  # Auto-calculate number of straps
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.CORE,
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m7,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.RINGS,  # Extend to the power rings
        nets = [])
    # Create power straps on metal7 with 1.4μm width and 10.8μm pitch
    pdngen.makeStrap(grid = g,
        layer = m8,
        width = design.micronToDBU(1.4),
        spacing = design.micronToDBU(1.4),
        pitch = design.micronToDBU(10.8),
        offset = design.micronToDBU(0),
        number_of_straps = 0,
        snap = False,
        starts_with = pdn.GRID,
        extend = pdn.BOUNDARY,  # Extend to the power rings
        nets = [])
  
    # Create via connections between power grid layers
    # Connect metal1 to metal4
    pdngen.makeConnect(grid = g,
        layer0 = m1,
        layer1 = m4, 
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal4 to metal7
    pdngen.makeConnect(grid = g,
        layer0 = m4,
        layer1 = m7,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")
    # Connect metal7 to metal8 (for ring connections)
    pdngen.makeConnect(grid = g,
        layer0 = m7,
        layer1 = m8,
        cut_pitch_x = pdn_cut_pitch[0],
        cut_pitch_y = pdn_cut_pitch[1],
        vias = [],
        techvias = [],
        max_rows = 0,
        max_columns = 0,
        ongrid = [],
        split_cuts = dict(),
        dont_use_vias = """")

# Create power grid for macro blocks
# Define additional metal layers for macro connections
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
m5 = design.getTech().getDB().getTech().findLayer(""metal5"")
m6 = design.getTech().getDB().getTech().findLayer(""metal6"")
# Set PG ring config for macros
macro_ring_width = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_spacing = [design.micronToDBU(1.5), design.micronToDBU(1.5)]
macro_ring_core_offset = [design.micronToDBU(0) for i in range(4)]
macro_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]
for i in range(len(macros)):
    # Create separate power grid for each macro instance
    for domain in domains:
        pdngen.makeInstanceGrid(domain = domain,
            name = ""CORE_macro_grid_"" + str(i),
            starts_with = pdn.GROUND,
            inst = macros[i],
            halo = halo,
            pg_pins_to_boundary = True,  # Connect power/ground pins to boundary
            default_grid = False, 
            generate_obstructions = [],
            is_bump = False)
    grid = pdngen.findGrid(""CORE_macro_grid_"" + str(i))
    for g in grid:
        # Create power ring around macro using metal5 and metal6
        pdngen.makeRing(grid = g, 
            layer0 = m5, 
            width0 = macro_ring_width[0], 
            spacing0 = macro_ring_spacing[0],
            layer1 = m6, 
            width1 = macro_ring_width[0], 
            spacing1 = macro_ring_spacing[0],
            starts_with = pdn.GRID, 
            offset = macro_ring_core_offset, 
            pad_offset = macro_ring_pad_offset, 
            extend = False,
            pad_pin_layers = macro_ring_connect_to_pad_layers, 
            nets = [])
        # Create power straps on metal5 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m5,
            width = design.micronToDBU(1.2), 
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,  # Snap to grid
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
        # Create power straps on metal6 for macro connections
        pdngen.makeStrap(grid = g,
            layer = m6,
            width = design.micronToDBU(1.2),
            spacing = design.micronToDBU(1.2),
            pitch = design.micronToDBU(6),
            offset = design.micronToDBU(0),
            number_of_straps = 0,
            snap = True,
            starts_with = pdn.GRID,
            extend = pdn.RINGS,
            nets = [])
    
        # Create via connections between macro power grid layers
        # Connect metal4 (from core grid) to metal5 (macro grid)
        pdngen.makeConnect(grid = g,
            layer0 = m4,
            layer1 = m5,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal5 to metal6 (macro grid layers)
        pdngen.makeConnect(grid = g,
            layer0 = m5,
            layer1 = m6,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")
        # Connect metal6 (macro grid) to metal7 (core grid)
        pdngen.makeConnect(grid = g,
            layer0 = m6,
            layer1 = m7,
            cut_pitch_x = pdn_cut_pitch[0],
            cut_pitch_y = pdn_cut_pitch[1],
            vias = [],
            techvias = [],
            max_rows = 0,
            max_columns = 0,
            ongrid = [],
            split_cuts = dict(),
            dont_use_vias = """")

# Generate the final power delivery network
pdngen.checkSetup()  # Verify configuration
pdngen.buildGrids(False)  # Build the power grid
pdngen.writeToDb(True, )  # Write power grid to the design database
pdngen.resetShapes()  # Reset temporary shapes 

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

# Write final odb file
design.writeDb(""final.odb"")

","
Load the Nangate45 library and technology files from the following paths: '../Design/nangate45/lib' for libraries and '../Design/nangate45/lef' for LEF files. You'll be working with the GCD design located at '../Design/6_dpl.odb'. Read the design into OpenROAD.

Set up the power delivery network (PDN) for your design:
- Create PG rings for standard cells using metal1, metal4, metal7, and metal8 with both width and spacing of 2 µm. Use metal1 for power straps, setting their width to 0.07 µm. On metal4, set straps with 1.2 µm width and spacing, and a pitch of 6 µm. For metal7 and metal8, configure straps with 1.4 µm width and spacing, and a pitch of 10.8 µm.
- For macros, design their PG rings using metal5 and metal6 with 1.5 µm width and spacing. Use 1.2 µm for PG straps' width and spacing with a pitch of 6 µm.

Define unit resistance as 0.03574 and unit capacitance as 0.07516. Use 'BUF_X2' for buffer cells in CTS. Insert filler cells as needed. Execute global routing from metal1 to metal7.

Finally, save your design as 'final.v' for the netlist file and 'final.odb' as the odb file.
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""7_pdn.odb"")
design.readDb(odbFile.as_posix())

# Configure and run clock tree synthesis
design.evalTclString(""set_propagated_clock [get_clocks {core_clock}]"")
# Set RC values for clock and signal nets
design.evalTclString(""set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516"")
design.evalTclString(""set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516"")
cts = design.getTritonCts()
parms = cts.getParms()
parms.setWireSegmentUnit(20)
# Configure clock buffers
cts.setBufferList(""BUF_X2"")
cts.setRootBuffer(""BUF_X2"")
cts.setSinkBuffer(""BUF_X2"")
cts.runTritonCts()

# Run final detailed placement
site = design.getBlock().getRows()[0].getSite()
max_disp_x = int(design.micronToDBU(1) / site.getWidth())
max_disp_y = int(design.micronToDBU(3) / site.getHeight())
design.getOpendp().detailedPlacement(max_disp_x, max_disp_y, """", False)

import openroad as ord
# Insert filler cells
db = ord.get_db()
filler_masters = list()
# filler cells' naming convention
filler_cells_prefix = ""FILLCELL_""
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == ""CORE_SPACER"":
            filler_masters.append(master)
if len(filler_masters) == 0:
    print(""no filler cells in library!"")
else:
    design.getOpendp().fillerPlacement(filler_masters = filler_masters, 
                                     prefix = filler_cells_prefix,
                                     verbose = False)

# Configure and run global routing
# Set routing layer ranges for signal and clock nets
signal_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
signal_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()
clk_low_layer = design.getTech().getDB().getTech().findLayer(""metal1"").getRoutingLevel()
clk_high_layer = design.getTech().getDB().getTech().findLayer(""metal7"").getRoutingLevel()

grt = design.getGlobalRouter()
grt.setMinRoutingLayer(signal_low_layer)
grt.setMaxRoutingLayer(signal_high_layer)
grt.setMinLayerForClock(clk_low_layer)
grt.setMaxLayerForClock(clk_high_layer)
grt.setAdjustment(0.5)
grt.setVerbose(True)
grt.globalRoute(True)

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

# Write final DEF file
design.writeDef(""final.def"")

# Write final Verilog file
design.evalTclString(""write_verilog final.v"")

# Write final odb file
design.writeDb(""final.odb"")

","
# Load Nangate45 tech and design files.
Library: ../Design/nangate45/lib/*.lib
LEF: ../Design/nangate45/lef/*.lef
Design: ../Design/7_pdn.odb

# Configure settings.
Set resistance: 0.03574
Set capacitance: 0.07516
Buffer: BUF_X2

# Execute tasks.
- Insert filler cells.
- Global route: metal1 to metal7.
- Detailed route.

# Save outputs.
DEF: final.def
Netlist: final.v
ODB: final.odb
"
"from openroad import Tech, Design, Timing
from pathlib import Path

# Initialize OpenROAD objects and read technology files
tech = Tech()
# Set paths to library and design files
libDir = Path(""../Design/nangate45/lib"")
lefDir = Path(""../Design/nangate45/lef"")
designDir = Path(""../Design/"")

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob(""*.lib"")
techLefFiles = lefDir.glob(""*.tech.lef"")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files  
for techLefFile in techLefFiles:
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
odbFile = designDir/str(""10_grt.odb"")
design.readDb(odbFile.as_posix())

import drt

# Configure and run detailed routing
drter = design.getTritonRoute()
params = drt.ParamStruct()
params.outputMazeFile = """"
params.outputDrcFile = """"
params.outputCmapFile = """"
params.outputGuideCoverageFile = """"
params.dbProcessNode = """"
params.enableViaGen = True
params.drouteEndIter = 1
params.viaInPinBottomLayer = """"
params.viaInPinTopLayer = """"
params.orSeed = -1
params.orK = 0
params.bottomRoutingLayer = ""metal1""
params.topRoutingLayer = ""metal7""
params.verbose = 1
params.cleanPatches = True
params.doPa = True
params.singleStepDR = False
params.minAccessPoints = 1
params.saveGuideUpdates = False
drter.setParams(params)
drter.main()

import psm

# Run static IR drop analysis
psm_obj = design.getPDNSim()
timing = Timing(design)
source_types = [psm.GeneratedSourceType_FULL,
    psm.GeneratedSourceType_STRAPS,
    psm.GeneratedSourceType_BUMPS]
# Analyze VDD power grid IR drop
psm_obj.analyzePowerGrid(net = design.getBlock().findNet(""VDD""),
    enable_em = False, corner = timing.getCorners()[0],
    use_prev_solution = False,
    em_file = """",
    error_file = """",
    voltage_source_file = """",
    voltage_file = """",
    source_type = source_types[2])

design.evalTclString(""report_power"")

","
Locate the Nangate45 library files in ../Design/nangate45/lib and the LEF files in ../Design/nangate45/lef. The GCD design is stored in ../Design/10_grt.odb. Load up the Nangate45 technology and import the design data into OpenROAD. Proceed with detailed routing. Perform a static IR drop analysis on the VDD net. Lastly, generate a report on switching, internal, and leakage power for the design.
"
